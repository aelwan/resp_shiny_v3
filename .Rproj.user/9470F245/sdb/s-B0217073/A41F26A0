{
    "collab_server" : "",
    "contents" : "\n\nserver <- function(input, output) {\n  \n  #leaflet map is create here, because it is used in both the app and in the report\n  lf <- reactive({\n    leaflet() %>% \n      addTiles((urlTemplate = \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\") ) %>%\n      fitBounds(176.4991,-39.7270,177.0382,-39.4487) %>% \n      addMapPane(name = \"raster\", zIndex = 410) %>% \n      addMapPane(name = \"wells\", zIndex = 420)\n  })\n  \n  \n  output$map <- renderLeaflet({\n\n    lf()\n  })\n  #observe map click and update input vith coordinates\n  observe({\n    if(input$pump_in_type == \"single point\"){\n      #input$map_clic\n      click <- input$map_shape_click\n      if(is.null(click))\n        return()\n      click_xy <- data.frame (lat = as.numeric(click$lat),\n                              lon = as.numeric(click$lng)) \n      #transfrm coordinates to nztm\n      click_xy <- st_as_sf(click_xy,coords = c(\"lon\", \"lat\"),crs = 4326)\n      click_xy <- st_transform(click_xy,2193)\n      click_xy$E <- st_coordinates(click_xy)[,1]\n      click_xy$N <- st_coordinates(click_xy)[,2]\n      click_xy <- st_set_geometry(click_xy, NULL)\n      click_xy_txt <- paste(click_xy[1,1],click_xy[1,2])\n      E <- click_xy[1,1]\n      N <- click_xy[1,2]\n      updateNumericInput(session,\n                         inputId = \"E\",\n                         label = \"Easting:\",\n                         value = E\n      )\n      updateNumericInput(session,\n                         inputId = \"N\",\n                         label = \"Northing:\",\n                         value = N\n      )  \n    }\n    \n  })\n  \n  wells_csv <- reactive({\n    \n    inFile <- input$file1\n    \n    if (is.null(inFile))\n      return(NULL)\n    \n    read_csv(inFile$datapath)\n    \n    \n  })\n  \n  well_csv_row <- reactive({\n    NROW(wells_csv())\n  })\n  \n  \n  \n  well_csv_ready <- reactive({\n    #if(exists (\"wells_csv()\" )==T){\n    if( well_csv_row()>0){\n      T\n      # }\n    }else{F}\n  })\n  \n  #generate data frame from input\n  wells <- reactive({\n    #input\n    if (well_csv_ready() == T & input$pump_in_type == 'upload csv') {\n      #impot csv\n      #wells <- read_csv(\"data/wells.csv\")\n      wells <-  wells_csv()\n      colnames(wells) <- c(\"x\",\"y\",\"Q\",\"L\")\n      wells <- wells[,1:4] \n    } else if (input$pump_in_type == \"historical data\" &  length(input$abstr_type >0) ){\n      load(\"data/wells/wells_hist.rdata\")\n      wells <- wells_hist %>% \n        filter(type %in%  input$abstr_type) %>% \n        mutate(Q=-Q)\n      \n      if (input$period_type == \"dry summer 2012-2013\"){\n        dates_range <- parse_date_time (c(\"1/11/2012\",\"1/03/2013\"),\"dmy\")\n      }\n      else if (input$period_type ==\"date range\"){\n        dates_range <- as_datetime(as_date(input$date_range_hist,origin = \"1970-01-01\"))\n        \n      }\n      wells <- wells %>% \n        filter(between(date,dates_range[1],dates_range[2]))  %>%  \n        filter(type %in%  input$abstr_type) %>%\n        group_by(x,y,L) %>%\n        summarise(Q = mean(Q))\n      \n      \n    }\n    else{\n      #generate well from input\n      wells <- data.frame(x = input$E,\n                          y= input$N,\n                          Q= input$Q,\n                          L=1) \n    }\n    \n    wells\n  })\n  \n  \n  \n  \n  \n  #convert wells to spatial and transform (for ploting locations)\n  wells1 <- reactive({\n    #####\n    #create a point for the selected location\n    #convert wells to lat long as set as spatial object for mapping in leaflet\n    wells1 <- st_as_sf(wells(),coords = c(\"x\", \"y\"),crs = 2193)\n    wells1 <- st_transform(wells1,4326)\n    wells1 <- as(wells1, 'Spatial')\n    wells1\n  })\n  \n  #get wells for sp (exptracting rasters etc)\n  wells_sp <- reactive({\n    #this is to add dummy row to avoid emty df\n    \n    wells_b <- bind_rows(wells(),wells_dummy)\n    \n    wells1_1 <- wells_b %>% \n      filter(L==1) %>% \n      st_as_sf(coords = c(\"x\", \"y\"),crs = 2193,remove = F)\n    wells_sp1 <- as(wells1_1, 'Spatial')\n    \n    wells1_2 <- wells_b %>% \n      filter(L==2) %>% \n      st_as_sf(coords = c(\"x\", \"y\"),crs = 2193,remove = F)\n    wells_sp2 <- as(wells1_2, 'Spatial')\n    \n    wells_sp <-list(wells_sp1,wells_sp2)\n    wells_sp\n  })\n  \n  #this is convenience fucntion to gather sp and data frmes into a list as argument tot_eff2 functon\n  wells_list <- reactive( {\n    wells1_1 <- wells() %>% \n      filter(L==1)\n    wells1_2 <- wells() %>% \n      filter(L==2)\n    wells_sp1 <- wells_sp()[[1]]\n    wells_sp2 <- wells_sp()[[2]]\n    wells_list <- list(wells_sp1,wells_sp2,wells1_1,wells1_2)\n    wells_list\n  })\n  \n  \n  # #generate raster from pumping\n  # commented out as not needed anymore\n  #  raster_pumping_comb <- reactive({\n  #    \n  #    #####\n  #    #generate pumping rater\n  #    \n  #    #function to process wells\n  #    raster_pumping_comb <- pump2rast(wells())\n  #  })\n  \n  \n  #generate a map with selected wells\n  map_point <- observe({\n    #add a marker to the map\n    proxy <- leafletProxy(\"map\")\n    proxy %>% \n      clearGroup(group = \"markers\") %>% \n      #removeMarker() %>% #clear old marker\n      addCircleMarkers(data = wells1(),  #add marker\n                       radius = ~Q/10,#4\n                       fillColor = \"blue\",\n                       stroke = F,\n                       fillOpacity = .7,\n                       group = \"markers\",\n                       options = leafletOptions(pane = \"wells\")\n                       \n      )\n  })\n  \n  time <- reactive({\n    time <- input$time\n    time <- as.integer(time)\n    df <- data.frame(comm_time=c(time)) %>% \n      left_join(times) %>% \n      select(id)\n    time <- unlist(df)\n    \n  })\n  zone <- reactive({\n    input$zone\n    # zone <- input$zone\n    # zone = \"ALLZN\"\n    # df<-data.frame(id = c(zone)) %>% \n    #   left_join(rivers,by = c(\"id\"=\"river\")) %>% \n    #   select(descr)\n    # zone <- unlist(df)\n  })\n  #layer <- input$Layer\n  \n  #generate \n  \n  perc <- \"Q50\"\n  RF_poly1 <- reactive({\n    #function to load raster\n    RF_comb <- SDZ_imp(zone(),time(),perc)\n    #output\n    RF_L1 <- RF_comb[[1]]\n    RF_L2 <- RF_comb[[2]]\n    \n    #projectRaster\n    # \n    # crs(RF_L1) <- nztm\n    # crs(RF_L2) <- nztm\n    \n    #add raster to the map\n    \n    if(as.numeric(input$Layer) == 1){\n      RF <- RF_L1\n    }  \n    else{\n      RF <- RF_L2\n    }\n    RF_poly <- rasterToPolygons(RF,na.rm=T) %>% \n      st_as_sf() %>% \n      st_set_crs(value= 2193) %>% \n      st_transform(crs = 4326)\n    names(RF_poly) <- c(\"SD\",\"geometry\")\n    RF_poly\n  })\n  labels1 <- reactive({\n    labels <- as.character(paste(\"stream depletion\",round(RF_poly1()$SD*100,2),\"%\",sep=\" \"))\n    labels\n  })\n  \n  \n  \n  \n  \n  #generate a map with selected raster (time, layer, zone)\n  map_raster <- observe({\n    \n    \n    proxy <- leafletProxy(\"map\")\n    proxy %>% \n      clearGroup(group = \"poly\") %>% \n      addPolygons(group = \"poly\",\n                  data=RF_poly1(),\n                  opacity = 1,\n                  fillOpacity = 0.7,\n                  stroke = F,\n                  fillColor = ~cb(SD*100),\n                  label= labels1(),\n                  labelOptions = labelOptions(\n                    style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n                    textsize = \"15px\",\n                    direction = \"auto\",\n                    clickable = F),\n                  options = leafletOptions(pane = \"raster\")\n      ) %>% \n      addLegend(layerId = \"legend\",\n                title = \"Stream Depletion %\",\n                pal = cb,\n                values= at ) \n    \n    \n    # test <- as.character(crs(RF))\n    #  test\n  })\n  \n  \n  \n  #generate dat frame for all zones\n  tot_effect_zones_df <- reactive({\n    \n    #####\n    #input\n    #time <- as.character(input$time)\n    \n    #loop through the zones to create a dataframe for plotting\n    for (z in 1: NROW(rivers)){\n      \n      zone_z <- unlist(rivers$river[z])\n      river_z <- unlist(rivers$descr[z])\n      \n      for (p in 1:3){\n        perc_p <- perc_s[p] \n        res <- tot_eff2(wells_list(),zone_z,time(),perc_p)%>% \n          mutate(zone = zone_z,\n                 river = river_z,\n                 perc = perc_p )\n        if(z==1 & p==1) {\n          res1 <- res\n        } else {\n          res1 <- bind_rows(res1,res) \n        }\n      }\n    }\n    res1 <- res1 %>% \n      select(-SD) %>% \n      spread(perc,SD_tot) %>% \n      mutate(river1 = str_wrap(river,width = 10))\n    res1\n  })\n  \n  tot_effect_zones_df_print <- reactive({\n    df <- tot_effect_zones_df() %>% \n      select(-x,-y,-Q,-L,zone) %>% \n      mutate_at(vars(Q10,Q50,Q90),funs(round(.,2)))\n  })\n  \n  #generate dat frame for all times\n  tot_effect_times_df <- reactive({\n    \n    #####\n    #input\n    zone <- zone()\n    \n    #loop through the zones to create a dataframe for plotting\n    for (t in 1: NROW(times)){\n      \n      time_t <- unlist(times[t,1])\n      time_t2 <- unlist(times[t,3])\n      for (p in 1:3){\n        perc_p <- perc_s[p] \n        res <- data.frame(SD_tot =tot_eff2_sum(tot_eff2(wells_list(),zone,time_t,perc_p))) %>% \n          mutate(time = time_t,\n                 perc = perc_p,\n                 time2 = time_t2)\n        if(t==1 & p==1) {\n          res1 <- res\n        } else {\n          res1 <- bind_rows(res1,res) \n        }\n      }\n    }\n    \n    res2 <- res1 %>% \n      spread(perc,SD_tot)\n    res2\n  })\n  \n  tot_effect_times_df_print <-  reactive({\n    df <- tot_effect_times_df() %>% \n      dplyr::select(-time) %>% \n      rename(time = time2) %>% \n      mutate_all(funs(round(.,2)))\n    \n    df\n  })\n  \n  \n  \n  \n  SDZ_perc <- reactive({\n    SDZ_perc <- round(sd_extract(wells1(),zone(),time(),as.numeric(input$Layer))*100,2)\n  })\n  \n  tot_effect_df <- reactive({\n    perc = \"Q50\"\n    tot_effect_df <- tot_eff2(wells_list(),zone(),time(),perc) %>% \n      mutate(perc = \"Q50\")\n    tot_effect_df\n  })\n  tot_effect10_df <- reactive({\n    perc = \"Q10\"\n    tot_effect_df <- tot_eff2(wells_list(),zone(),time(),perc) %>% \n      mutate(perc = \"Q10\")\n    tot_effect_df\n  })\n  tot_effect90_df <- reactive({\n    perc = \"Q90\"\n    tot_effect_df <- tot_eff2(wells_list(),zone(),time(),perc)%>% \n      mutate(perc = \"Q90\")\n    tot_effect_df\n  })\n  \n  \n  tot_effect_df_print <- reactive({\n    df <- bind_rows(tot_effect_df(),tot_effect10_df(),tot_effect90_df()) %>% \n      rename(SDR = SD,\n             SD = SD_tot,\n             quantile = perc) %>% \n      mutate_at(vars(SD,SDR),funs(round(.,2))) %>% \n      select(x,y,L,Q,SDR,SD,quantile)\n    \n  })\n  \n  \n  \n  tot_effect <- reactive({\n    # df <- tot_eff_calc(input$zone,input$time,raster_pumping_comb()) %>% \n    #   select(tot_effect)\n    # df <- round(unlist(df),2)\n    perc = \"Q50\"\n    df <- tot_eff2_sum(tot_effect_df())\n    df <- round(df,1)\n    df\n  })\n  \n  \n  \n  \n  \n  \n  tot_effect_10 <- reactive({\n    # df <- tot_eff_calc(input$zone,input$time,raster_pumping_comb()) %>% \n    #   select(tot_effect)\n    # df <- round(unlist(df),2)\n    perc = \"Q10\"\n    df <- tot_eff2_sum(tot_eff2(wells_list(),zone(),time(),perc))\n    df <- round(df,1)\n    df\n  })\n  \n  tot_effect_90 <- reactive({\n    # df <- tot_eff_calc(input$zone,input$time,raster_pumping_comb()) %>% \n    #   select(tot_effect)\n    # df <- round(unlist(df),2)\n    perc = \"Q90\"\n    df <- tot_eff2_sum(tot_eff2(wells_list(),zone(),time(),perc))\n    df <- round(df,1)\n    df\n  })\n  \n  \n  \n  \n  \n  output$tot_effect_out <- renderText({\n    paste( tot_effect(),\"(\",tot_effect_10(),\" - \",tot_effect_90(),\")\",\"L/s\")\n  })\n  \n  \n  output$SDZ_out <- renderText({\n    paste( SDZ_perc(),\"%\")\n  }) \n  \n  output$tot_effect_out_label <- renderText({\n    \"Total effect on selected stream from pumping for specified location, rate and duration:\"\n  })\n  output$SDZ_out_label <- renderText({\n    \"Stream depletion as % of pumping:\"\n  }) \n  chart_bar1 <- reactive({\n    chart <- tot_effect_zones_df() %>% \n      ggplot(aes(zone,Q50,fill = river))+\n      geom_bar(stat = \"identity\")+\n      geom_errorbar(aes(ymin = Q10, ymax = Q90),\n                    width = .2)+\n      theme(legend.position = \"none\",axis.text.x = element_text(angle = 90, hjust = 1))+\n      ggtitle(\"Effect vs stream (for selected time) \")+\n      ylab(\"Effect L/s\")+\n      xlab(\"Streams\")\n    \n    chart\n    #+ theme(legend.position = \"none\"))\n  })\n  \n  \n  \n  \n  \n  \n  \n  \n  output$bar_chart <- renderPlotly({\n    \n    ggplotly(chart_bar1())\n    #ggplot(tot_effect_df(),aes(zone_z,tot_effect))+geom_bar(stat = \"identity\")\n  })\n  \n  \n  chart_line1 <- reactive({\n    chart <- ggplot(data =tot_effect_times_df(),aes(x=time2,y=Q50))+\n      geom_ribbon(aes(ymin=Q10, ymax=Q90),fill = \"gray70\")+\n      geom_line(col = \"red\")+\n      theme(legend.position = \"none\",axis.text.x = element_text(angle = 90, hjust = 1))+\n      ggtitle(\"Effect vs time (for selected stream) \")+\n      ylab(\"Effect L/s\")+\n      xlab(\"Time days\")\n    chart\n  })\n  \n  output$line_chart <- renderPlotly({\n    \n    #chart\n    #+ theme(legend.position = \"none\"))\n    ggplotly(chart_line1())\n    #ggplot(tot_effect_df(),aes(zone_z,tot_effect))+geom_bar(stat = \"identity\")\n  })\n  output$test1 <- renderText(map_raster())\n  \n  output$event <- renderPrint({\n    d <- event_data(\"plotly_hover\")\n    if (is.null(d)) \"Hover on a point!\" else round(d$y,1)\n  })\n  \n  output$wells_tab <- renderDataTable(tot_effect_df_print())\n  output$zones_tab <- renderDataTable(tot_effect_zones_df_print())\n  output$times_tab <- renderDataTable(tot_effect_times_df_print())\n  \n  #download section\n  #\n  # download a report\n  output$downloadReport <- downloadHandler(\n    # For PDF output, change this to \"report.pdf\"\n    filename = \"report.pdf\",\n    content = function(file) {\n      # Copy the report file to a temporary directory before processing it, in\n      # case we don't have write permissions to the current working dir (which\n      # can happen when deployed).\n      tempReport <- file.path(tempdir(), \"report.Rmd\")\n      file.copy(\"report.Rmd\", tempReport, overwrite = TRUE)\n      \n      # Set up parameters to pass to Rmd document\n      params <- list(chart_line = chart_line1(),\n                     chart_bar = chart_bar1(),\n                     map = lf(),\n                     wells = wells1(),\n                     raster = RF_poly1(),\n                     labels = labels1() )\n      \n      # Knit the document, passing in the `params` list, and eval it in a\n      # child of the global environment (this isolates the code in the document\n      # from the code in this app).\n      rmarkdown::render(tempReport, output_file = file,\n                        params = params,\n                        envir = new.env(parent = globalenv())#,\n                        #output_format = \"pdf_document\",\n                        #output_file = \"report.pdf\"\n      )\n    }\n  )\n  \n  output$downloadData_bore <- downloadHandler(\n    filename = \"SD_per_bore.csv\",\n    content = function(file) {\n      write.csv(tot_effect_df_print() , file = file, row.names = FALSE)\n    }\n  )\n  \n  output$downloadData_river <- downloadHandler(\n    filename = \"SD_per_river.csv\",\n    content = function(file) {\n      write.csv(tot_effect_zones_df_print() , file = file, row.names = FALSE)\n    }\n  )\n  \n  output$downloadData_times <- downloadHandler(\n    filename = \"SD_per_times.csv\",\n    content = function(file) {\n      write.csv(tot_effect_times_df_print() , file = file, row.names = FALSE)\n    }\n  )\n  \n  \n}",
    "created" : 1549509823043.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "548031984",
    "id" : "A41F26A0",
    "lastKnownWriteTime" : 1549514032,
    "last_content_update" : 1549567661016,
    "path" : "C:/PAWEL/R/resp_shiny_v3/server.R",
    "project_path" : "server.R",
    "properties" : {
        "marks" : "<:184,38\n>:184,40",
        "tempName" : "Untitled9"
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}